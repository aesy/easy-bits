<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>BitArray.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BitArray.html">BitArray</a><ul class='methods'><li data-type='method'><a href="BitArray.html#.deserialize">deserialize</a></li><li data-type='method'><a href="BitArray.html#.fromArray">fromArray</a></li><li data-type='method'><a href="BitArray.html#clone">clone</a></li><li data-type='method'><a href="BitArray.html#copy">copy</a></li><li data-type='method'><a href="BitArray.html#count">count</a></li><li data-type='method'><a href="BitArray.html#equals">equals</a></li><li data-type='method'><a href="BitArray.html#flip">flip</a></li><li data-type='method'><a href="BitArray.html#flipAll">flipAll</a></li><li data-type='method'><a href="BitArray.html#flipAt">flipAt</a></li><li data-type='method'><a href="BitArray.html#flipRange">flipRange</a></li><li data-type='method'><a href="BitArray.html#get">get</a></li><li data-type='method'><a href="BitArray.html#getRange">getRange</a></li><li data-type='method'><a href="BitArray.html#intersect">intersect</a></li><li data-type='method'><a href="BitArray.html#intersects">intersects</a></li><li data-type='method'><a href="BitArray.html#off">off</a></li><li data-type='method'><a href="BitArray.html#on">on</a></li><li data-type='method'><a href="BitArray.html#serialize">serialize</a></li><li data-type='method'><a href="BitArray.html#set">set</a></li><li data-type='method'><a href="BitArray.html#setAll">setAll</a></li><li data-type='method'><a href="BitArray.html#setAt">setAt</a></li><li data-type='method'><a href="BitArray.html#setRange">setRange</a></li><li data-type='method'><a href="BitArray.html#test">test</a></li><li data-type='method'><a href="BitArray.html#testAll">testAll</a></li><li data-type='method'><a href="BitArray.html#testAny">testAny</a></li><li data-type='method'><a href="BitArray.html#testAt">testAt</a></li><li data-type='method'><a href="BitArray.html#toArray">toArray</a></li><li data-type='method'><a href="BitArray.html#toString">toString</a></li><li data-type='method'><a href="BitArray.html#valueOf">valueOf</a></li></ul></li><li><a href="BitField.html">BitField</a><ul class='methods'><li data-type='method'><a href="BitField.html#.deserialize">deserialize</a></li><li data-type='method'><a href="BitField.html#.fromArray">fromArray</a></li><li data-type='method'><a href="BitField.html#clone">clone</a></li><li data-type='method'><a href="BitField.html#copy">copy</a></li><li data-type='method'><a href="BitField.html#count">count</a></li><li data-type='method'><a href="BitField.html#equals">equals</a></li><li data-type='method'><a href="BitField.html#flip">flip</a></li><li data-type='method'><a href="BitField.html#flipAll">flipAll</a></li><li data-type='method'><a href="BitField.html#flipAt">flipAt</a></li><li data-type='method'><a href="BitField.html#flipRange">flipRange</a></li><li data-type='method'><a href="BitField.html#get">get</a></li><li data-type='method'><a href="BitField.html#getRange">getRange</a></li><li data-type='method'><a href="BitField.html#intersect">intersect</a></li><li data-type='method'><a href="BitField.html#intersects">intersects</a></li><li data-type='method'><a href="BitField.html#off">off</a></li><li data-type='method'><a href="BitField.html#on">on</a></li><li data-type='method'><a href="BitField.html#serialize">serialize</a></li><li data-type='method'><a href="BitField.html#set">set</a></li><li data-type='method'><a href="BitField.html#setAll">setAll</a></li><li data-type='method'><a href="BitField.html#setAt">setAt</a></li><li data-type='method'><a href="BitField.html#setRange">setRange</a></li><li data-type='method'><a href="BitField.html#test">test</a></li><li data-type='method'><a href="BitField.html#testAll">testAll</a></li><li data-type='method'><a href="BitField.html#testAny">testAny</a></li><li data-type='method'><a href="BitField.html#testAt">testAt</a></li><li data-type='method'><a href="BitField.html#toArray">toArray</a></li><li data-type='method'><a href="BitField.html#toString">toString</a></li><li data-type='method'><a href="BitField.html#valueOf">valueOf</a></li></ul></li><li><a href="BitFlags.html">BitFlags</a><ul class='methods'><li data-type='method'><a href="BitFlags.html#.deserialize">deserialize</a></li><li data-type='method'><a href="BitFlags.html#.fromArray">fromArray</a></li><li data-type='method'><a href="BitFlags.html#createBitArray">createBitArray</a></li><li data-type='method'><a href="BitFlags.html#createBitField">createBitField</a></li><li data-type='method'><a href="BitFlags.html#forEach">forEach</a></li><li data-type='method'><a href="BitFlags.html#has">has</a></li><li data-type='method'><a href="BitFlags.html#serialize">serialize</a></li><li data-type='method'><a href="BitFlags.html#toString">toString</a></li><li data-type='method'><a href="BitFlags.html#values">values</a></li></ul></li><li><a href="Enum.html">Enum</a><ul class='methods'><li data-type='method'><a href="Enum.html#.deserialize">deserialize</a></li><li data-type='method'><a href="Enum.html#.fromArray">fromArray</a></li><li data-type='method'><a href="Enum.html#forEach">forEach</a></li><li data-type='method'><a href="Enum.html#has">has</a></li><li data-type='method'><a href="Enum.html#serialize">serialize</a></li><li data-type='method'><a href="Enum.html#toString">toString</a></li><li data-type='method'><a href="Enum.html#values">values</a></li></ul></li></ul><h3>Interfaces</h3><ul><li><a href="BitSet.html">BitSet</a><ul class='methods'><li data-type='method'><a href="BitSet.html#copy">copy</a></li><li data-type='method'><a href="BitSet.html#count">count</a></li><li data-type='method'><a href="BitSet.html#equals">equals</a></li><li data-type='method'><a href="BitSet.html#flip">flip</a></li><li data-type='method'><a href="BitSet.html#flipAll">flipAll</a></li><li data-type='method'><a href="BitSet.html#flipAt">flipAt</a></li><li data-type='method'><a href="BitSet.html#flipRange">flipRange</a></li><li data-type='method'><a href="BitSet.html#get">get</a></li><li data-type='method'><a href="BitSet.html#getRange">getRange</a></li><li data-type='method'><a href="BitSet.html#intersect">intersect</a></li><li data-type='method'><a href="BitSet.html#intersects">intersects</a></li><li data-type='method'><a href="BitSet.html#off">off</a></li><li data-type='method'><a href="BitSet.html#on">on</a></li><li data-type='method'><a href="BitSet.html#serialize">serialize</a></li><li data-type='method'><a href="BitSet.html#set">set</a></li><li data-type='method'><a href="BitSet.html#setAll">setAll</a></li><li data-type='method'><a href="BitSet.html#setAt">setAt</a></li><li data-type='method'><a href="BitSet.html#setRange">setRange</a></li><li data-type='method'><a href="BitSet.html#test">test</a></li><li data-type='method'><a href="BitSet.html#testAll">testAll</a></li><li data-type='method'><a href="BitSet.html#testAny">testAny</a></li><li data-type='method'><a href="BitSet.html#testAt">testAt</a></li><li data-type='method'><a href="BitSet.html#toArray">toArray</a></li><li data-type='method'><a href="BitSet.html#toString">toString</a></li><li data-type='method'><a href="BitSet.html#valueOf">valueOf</a></li></ul></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<div id="main">
    
    <h1 class="page-title">BitArray.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { assertTrue, isInteger } from './util';

/**
 * A {@link BitSet} implementation with no limit due to bits being stored in an array. Also known as bit set, bit map
 * or bit vector. This implementation will never throw out of bounds errors.
 *
 * @public
 * @class
 * @implements {BitSet}
 */
class BitArray {
	/**
	 * An array containing each bit as a boolean value, starting from the rightmost bit.
	 *
	 * @private
	 * @member {Array&lt;Boolean>}
	 */
	value;

	/**
	 * @public
	 * @constructor
	 * @param {Number} [minLength = 1] The minimum length of the bitArray.
	 * @throws {Error} In case 'minLength' is equals to or smaller than zero.
	 */
	constructor(minLength) {
		assertTrue(minLength === undefined || minLength > 0,
			'Illegal argument: parameter \'minLength\' must be larger than 0');

		minLength = minLength || 1;

		this.value = [];

		for (let i = 0; i &lt; minLength; i++) {
			this.value.push(false);
		}
	}

	/**
	 * Combines masks. This is equivalent to a OR operation.
	 *
	 * @private
	 * @static
	 * @param {...BitMask} masks The masks to combine.
	 * @returns {BitArray} The resulting mask.
	 */
	static combineMasks(...masks) {
		const bitArray = new BitArray();
		const tempArray = new BitArray();

		for (const mask of masks) {
			tempArray.copy(mask);

			for (let i = 0; i &lt; tempArray.length; i++) {
				const oldBit = bitArray.get(i);
				const newBit = tempArray.get(i);
				bitArray.setAt(oldBit || newBit, i);
			}
		}

		return bitArray;
	}

	/**
	 * Produces a new BitArray instance from a value. The value may contain anything, the resulting bitArray is based
	 * on the truthiness of the value contents.
	 * Example: [true, 0, {}] will yield 101.
	 *
	 * @public
	 * @static
	 * @param {Array&lt;*>} array
	 * @returns {BitArray} A new BitArray instance.
	 */
	static fromArray(array) {
		const bitArray = new BitArray();

		bitArray.value = array.slice(0).reverse().map(Boolean);

		return bitArray;
	}

	get length() {
		return this.value.length;
	}

	count() {
		return this.value.filter(value => value).length;
	}

	intersect(...masks) {
		const bitArray = BitArray.combineMasks(...masks);
		const length = Math.max(bitArray.length, this.length);

		for (let i = 0; i &lt; length; i++) {
			const thisBit = this.get(i);
			const otherBit = bitArray.get(i);

			this.setAt(thisBit &amp;&amp; otherBit, i);
		}

		return this;
	}

	intersects(...masks) {
		const bitArray = BitArray.combineMasks(...masks);
		const length = Math.max(bitArray.length, this.length);

		for (let i = 0; i &lt; length; i++) {
			const thisBit = this.get(i);
			const otherBit = bitArray.get(i);

			if (thisBit &amp;&amp; otherBit) {
				return true;
			}
		}

		return false;
	}

	get(index) {
		assertTrue(isInteger(index), 'Illegal argument: parameter \'index\' is not an integer');

		return this.value[index] || false;
	}

	getRange(from, to) {
		assertTrue(isInteger(from), 'Illegal argument: parameter \'from\' is not an integer');
		assertTrue(isInteger(to), 'Illegal argument: parameter \'to\' is not an integer');
		assertTrue(to > from, 'Illegal argument: parameter \'to\' must be larger than parameter \'from\'');

		const length = to - from;
		const bitArray = new BitArray();
		bitArray.value = this.value.slice(from, to);

		while (bitArray.length &lt; length) {
			bitArray.value.push(false);
		}

		return bitArray;
	}

	test(...masks) {
		const mask = BitArray.combineMasks(...masks);

		for (let i = 0; i &lt; mask.length; i++) {
			const bit = mask.get(i);

			if (bit &amp;&amp; !this.get(i)) {
				return false;
			}
		}

		return true;
	}

	testAny(...masks) {
		const mask = BitArray.combineMasks(...masks);

		for (let i = 0; i &lt; mask.length; i++) {
			const bit = mask.get(i);

			if (bit &amp;&amp; this.get(i)) {
				return true;
			}
		}

		return false;
	}

	testAt(value, index) {
		assertTrue(isInteger(index), 'Illegal argument: parameter \'index\' is not an integer');

		if (index > this.length) {
			return Boolean(value) === false;
		}

		return Boolean(value) === this.get(index);
	}

	testAll(value) {
		value = Boolean(value);

		return this.value.every(element => element === value);
	}

	on(...masks) {
		return this.set(1, ...masks);
	}

	off(...masks) {
		return this.set(0, ...masks);
	}

	set(value, ...masks) {
		const mask = BitArray.combineMasks(...masks);

		for (let i = 0; i &lt; mask.length; i++) {
			const bit = mask.get(i);

			if (bit) {
				this.setAt(value, i);
			}
		}

		return this;
	}

	setAll(value) {
		this.value.fill(Boolean(value));

		return this;
	}

	setAt(value, index) {
		assertTrue(isInteger(index), 'Illegal argument: parameter \'index\' is not an integer');

		while (index >= this.length) {
			this.value.push(false);
		}

		this.value[index] = Boolean(value);

		return this;
	}

	setRange(value, from, to) {
		assertTrue(isInteger(from), 'Illegal argument: parameter \'from\' is not an integer');
		assertTrue(isInteger(to), 'Illegal argument: parameter \'to\' is not an integer');
		assertTrue(to > from, 'Illegal argument: parameter \'to\' must be larger than parameter \'from\'');

		for (let i = from; i &lt; to; i++) {
			this.setAt(value, i);
		}

		return this;
	}

	flip(...masks) {
		const mask = BitArray.combineMasks(...masks);

		for (let i = 0; i &lt; mask.length; i++) {
			const bit = mask.get(i);

			if (bit) {
				this.flipAt(i);
			}
		}

		return this;
	}

	flipAll() {
		for (let i = 0; i &lt; this.length; i++) {
			this.flipAt(i);
		}

		return this;
	}

	flipAt(index) {
		assertTrue(isInteger(index), 'Illegal argument: parameter \'index\' is not an integer');

		while (index >= this.length) {
			this.value.push(false);
		}

		this.setAt(!this.get(index), index);

		return this;
	}

	flipRange(from, to) {
		assertTrue(isInteger(from), 'Illegal argument: parameter \'from\' is not an integer');
		assertTrue(isInteger(to), 'Illegal argument: parameter \'to\' is not an integer');
		assertTrue(to > from, 'Illegal argument: parameter \'to\' must be larger than parameter \'from\'');

		for (let i = from; i &lt; to; i++) {
			this.flipAt(i);
		}

		return this;
	}

	copy(bitset) {
		this.value.fill(false);

		if (bitset instanceof Object) {
			const array = bitset.toArray().reverse();
			this.value.splice(0, array.count, ...array);
		} else {
			let index = 0;

			while (bitset > 0) {
				this.setAt(bitset &amp; 1, index);
				bitset >>= 1;
				index++;
			}
		}

		return this;
	}

	/**
	 * Gets the integer value of this instance.
	 *
	 * @public
	 * @throws {Error} In case this instance cannot be represented by an integer (by exceeding 31 bits).
	 * @returns {Number}
	 */
	valueOf() {
		if (this.length > 31) {
			throw new Error('Number exceeds 31 bits');
		}

		return this.toArray().reduce((prev, curr) => {
			prev &lt;&lt;= 1;

			if (curr) {
				prev++;
			}

			return prev;
		}, 0);
	}

	serialize() {
		return this.toArray().map(Number).join('');
	}

	/**
	 * Deserializes a string and returns a new instance.
	 *
	 * @public
	 * @static
	 * @param {String} input
	 * @throws {Error} In case input could not be parsed.
	 * @returns {BitArray} A new instance.
	 */
	static deserialize(input) {
		const array = input.split('');

		if (array.some(isNaN)) {
			throw new Error('Failed to deserialize input');
		}

		return BitArray.fromArray(array.map(Number));
	}

	/**
	 * Produces a new BitArray instance equal to this.
	 *
	 * @public
	 * @returns {BitArray} A new BitArray instance.
	 */
	clone() {
		return new BitArray().copy(this);
	}

	equals(other) {
		const bitArray = new BitArray().copy(other);
		const length = Math.max(this.length, bitArray.length);

		for (let i = 0; i &lt; length; i++) {
			if (this.get(i) !== bitArray.get(i)) {
				return false;
			}
		}

		return true;
	}

	toArray() {
		return this.value.slice(0).reverse();
	}

	toString() {
		return `BitArray(${this.serialize()})`;
	}
}

export default BitArray;
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a> on Sat Mar 06 2021 19:45:42 GMT+0100 (Central European Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
