<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>BitField.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BitArray.html">BitArray</a><ul class='methods'><li data-type='method'><a href="BitArray.html#.deserialize">deserialize</a></li><li data-type='method'><a href="BitArray.html#.fromArray">fromArray</a></li><li data-type='method'><a href="BitArray.html#clone">clone</a></li><li data-type='method'><a href="BitArray.html#copy">copy</a></li><li data-type='method'><a href="BitArray.html#count">count</a></li><li data-type='method'><a href="BitArray.html#equals">equals</a></li><li data-type='method'><a href="BitArray.html#flip">flip</a></li><li data-type='method'><a href="BitArray.html#flipAll">flipAll</a></li><li data-type='method'><a href="BitArray.html#flipAt">flipAt</a></li><li data-type='method'><a href="BitArray.html#flipRange">flipRange</a></li><li data-type='method'><a href="BitArray.html#get">get</a></li><li data-type='method'><a href="BitArray.html#getRange">getRange</a></li><li data-type='method'><a href="BitArray.html#intersect">intersect</a></li><li data-type='method'><a href="BitArray.html#intersects">intersects</a></li><li data-type='method'><a href="BitArray.html#off">off</a></li><li data-type='method'><a href="BitArray.html#on">on</a></li><li data-type='method'><a href="BitArray.html#serialize">serialize</a></li><li data-type='method'><a href="BitArray.html#set">set</a></li><li data-type='method'><a href="BitArray.html#setAll">setAll</a></li><li data-type='method'><a href="BitArray.html#setAt">setAt</a></li><li data-type='method'><a href="BitArray.html#setRange">setRange</a></li><li data-type='method'><a href="BitArray.html#test">test</a></li><li data-type='method'><a href="BitArray.html#testAll">testAll</a></li><li data-type='method'><a href="BitArray.html#testAny">testAny</a></li><li data-type='method'><a href="BitArray.html#testAt">testAt</a></li><li data-type='method'><a href="BitArray.html#toArray">toArray</a></li><li data-type='method'><a href="BitArray.html#toString">toString</a></li><li data-type='method'><a href="BitArray.html#valueOf">valueOf</a></li></ul></li><li><a href="BitField.html">BitField</a><ul class='methods'><li data-type='method'><a href="BitField.html#.deserialize">deserialize</a></li><li data-type='method'><a href="BitField.html#.fromArray">fromArray</a></li><li data-type='method'><a href="BitField.html#clone">clone</a></li><li data-type='method'><a href="BitField.html#copy">copy</a></li><li data-type='method'><a href="BitField.html#count">count</a></li><li data-type='method'><a href="BitField.html#equals">equals</a></li><li data-type='method'><a href="BitField.html#flip">flip</a></li><li data-type='method'><a href="BitField.html#flipAll">flipAll</a></li><li data-type='method'><a href="BitField.html#flipAt">flipAt</a></li><li data-type='method'><a href="BitField.html#flipRange">flipRange</a></li><li data-type='method'><a href="BitField.html#get">get</a></li><li data-type='method'><a href="BitField.html#getRange">getRange</a></li><li data-type='method'><a href="BitField.html#intersect">intersect</a></li><li data-type='method'><a href="BitField.html#intersects">intersects</a></li><li data-type='method'><a href="BitField.html#off">off</a></li><li data-type='method'><a href="BitField.html#on">on</a></li><li data-type='method'><a href="BitField.html#serialize">serialize</a></li><li data-type='method'><a href="BitField.html#set">set</a></li><li data-type='method'><a href="BitField.html#setAll">setAll</a></li><li data-type='method'><a href="BitField.html#setAt">setAt</a></li><li data-type='method'><a href="BitField.html#setRange">setRange</a></li><li data-type='method'><a href="BitField.html#test">test</a></li><li data-type='method'><a href="BitField.html#testAll">testAll</a></li><li data-type='method'><a href="BitField.html#testAny">testAny</a></li><li data-type='method'><a href="BitField.html#testAt">testAt</a></li><li data-type='method'><a href="BitField.html#toArray">toArray</a></li><li data-type='method'><a href="BitField.html#toString">toString</a></li><li data-type='method'><a href="BitField.html#valueOf">valueOf</a></li></ul></li><li><a href="BitFlags.html">BitFlags</a><ul class='methods'><li data-type='method'><a href="BitFlags.html#.deserialize">deserialize</a></li><li data-type='method'><a href="BitFlags.html#.fromArray">fromArray</a></li><li data-type='method'><a href="BitFlags.html#createBitArray">createBitArray</a></li><li data-type='method'><a href="BitFlags.html#createBitField">createBitField</a></li><li data-type='method'><a href="BitFlags.html#forEach">forEach</a></li><li data-type='method'><a href="BitFlags.html#has">has</a></li><li data-type='method'><a href="BitFlags.html#serialize">serialize</a></li><li data-type='method'><a href="BitFlags.html#toString">toString</a></li><li data-type='method'><a href="BitFlags.html#values">values</a></li></ul></li><li><a href="Enum.html">Enum</a><ul class='methods'><li data-type='method'><a href="Enum.html#.deserialize">deserialize</a></li><li data-type='method'><a href="Enum.html#.fromArray">fromArray</a></li><li data-type='method'><a href="Enum.html#forEach">forEach</a></li><li data-type='method'><a href="Enum.html#has">has</a></li><li data-type='method'><a href="Enum.html#serialize">serialize</a></li><li data-type='method'><a href="Enum.html#toString">toString</a></li><li data-type='method'><a href="Enum.html#values">values</a></li></ul></li></ul><h3>Interfaces</h3><ul><li><a href="BitSet.html">BitSet</a><ul class='methods'><li data-type='method'><a href="BitSet.html#copy">copy</a></li><li data-type='method'><a href="BitSet.html#count">count</a></li><li data-type='method'><a href="BitSet.html#equals">equals</a></li><li data-type='method'><a href="BitSet.html#flip">flip</a></li><li data-type='method'><a href="BitSet.html#flipAll">flipAll</a></li><li data-type='method'><a href="BitSet.html#flipAt">flipAt</a></li><li data-type='method'><a href="BitSet.html#flipRange">flipRange</a></li><li data-type='method'><a href="BitSet.html#get">get</a></li><li data-type='method'><a href="BitSet.html#getRange">getRange</a></li><li data-type='method'><a href="BitSet.html#intersect">intersect</a></li><li data-type='method'><a href="BitSet.html#intersects">intersects</a></li><li data-type='method'><a href="BitSet.html#off">off</a></li><li data-type='method'><a href="BitSet.html#on">on</a></li><li data-type='method'><a href="BitSet.html#serialize">serialize</a></li><li data-type='method'><a href="BitSet.html#set">set</a></li><li data-type='method'><a href="BitSet.html#setAll">setAll</a></li><li data-type='method'><a href="BitSet.html#setAt">setAt</a></li><li data-type='method'><a href="BitSet.html#setRange">setRange</a></li><li data-type='method'><a href="BitSet.html#test">test</a></li><li data-type='method'><a href="BitSet.html#testAll">testAll</a></li><li data-type='method'><a href="BitSet.html#testAny">testAny</a></li><li data-type='method'><a href="BitSet.html#testAt">testAt</a></li><li data-type='method'><a href="BitSet.html#toArray">toArray</a></li><li data-type='method'><a href="BitSet.html#toString">toString</a></li><li data-type='method'><a href="BitSet.html#valueOf">valueOf</a></li></ul></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<div id="main">
    
    <h1 class="page-title">BitField.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { assertTrue, isInteger, withinRange } from './util';

/**
 * A {@link BitSet} implementation limited to 31 bits due to bits being stored in a Number type.
 * This implementation is about 25% faster than a BitArray.
 *
 * @public
 * @class
 * @implements {BitSet}
 */
class BitField {
	/**
	 * The bitfields' current value.
	 *
	 * @private
	 * @member {Number}
	 */
	value = 0;

	/**
	 * The bitfields' minimum length.
	 * Example: a bitfield with a value of 110 (base 2) and a minimum length of 4 makes it so that the value is treated
	 * as 0110. Thus the flipAll method will yield 1001, instead of 001, which would be the result without pre-assigned
	 * length.
	 *
	 * @private
	 * @readonly
	 * @member {Number}
	 */
	minLength;

	/**
	 * @public
	 * @constructor
	 * @param {Number} [minLength = 1] The minimum length of the bitfield.
     * @throws {Error} In case length exceeds 31 (consider using BitArray instead if u may reach this limit).
     * @throws {Error} In case 'minLength' is equals to or smaller than zero.
	 */
	constructor(minLength) {
		assertTrue(minLength === undefined || minLength > 0,
			'Illegal argument: parameter \'minLength\' must be larger than 0');

		this.minLength = minLength || 1;

		if (this.minLength > 31) {
			throw new Error('BitField is limited to 31 flags');
		}
	}

	/**
	 * Gets the integer value of a bitsetlike value or instance.
	 *
	 * @private
	 * @static
	 * @param {BitSetLike} value
	 * @returns {Number} The value.
	 */
	static valueOf(value) {
		if (value instanceof Object) {
			return value.valueOf();
		}

		return value;
	}

	/**
	 * Combines masks. This is equivalent to a OR operation.
	 *
	 * @private
	 * @static
	 * @param {...BitMask} masks The masks to combine.
	 * @returns {Number} The resulting mask.
	 */
	static combineMasks(...masks) {
		return masks.reduce((prev, curr) => prev | curr, 0);
	}

	/**
	 * Produces a new BitField instance from an array. The value may contain anything, the resulting bitfield is based
	 * on the truthiness of the value contents.
	 * Example: [true, 0, {}] will yield 101.
	 *
	 * @public
	 * @static
	 * @param {Array&lt;*>} array
	 * @throws {Error} In case length exceeds 31 (consider using BitArray instead if u may reach this limit).
	 * @returns {BitField} A new BitField instance.
	 */
	static fromArray(array) {
		let length = 0;

		const bitMask = array.reduce((prev, curr) => {
			length++;
			prev &lt;&lt;= 1;

			if (curr) {
				prev++;
			}

			return prev;
		}, 0);

		return new BitField(length).on(bitMask);
	}

	get length() {
		let { value } = this;
		let length = 0;

		while (value > 0) {
			length++;
			value >>= 1;
		}

		return Math.max(this.minLength, length);
	}

	count() {
		let { value } = this;
		let count = 0;

		while (value > 0) {
			if (value &amp; 1) {
				count++;
			}

			value >>= 1;
		}

		return count;
	}

	intersect(...masks) {
		this.value &amp;= BitField.combineMasks(...masks);

		return this;
	}

	intersects(...masks) {
		const mask = BitField.combineMasks(...masks);

		return (this.value &amp; mask) !== 0;
	}

	get(index) {
		assertTrue(isInteger(index), 'Illegal argument: parameter \'index\' is not an integer');
		assertTrue(withinRange(index, 0, 31), 'Illegal argument: parameter \'index\' is out of bounds');

		return Boolean((this.value >> index) &amp; 1);
	}

	getRange(from, to) {
		assertTrue(isInteger(from), 'Illegal argument: parameter \'from\' is not an integer');
		assertTrue(isInteger(to), 'Illegal argument: parameter \'to\' is not an integer');
		assertTrue(withinRange(from, 0, 31), 'Illegal argument: parameter \'from\' is out of bounds');
		assertTrue(withinRange(to, 0, 31), 'Illegal argument: parameter \'to\' is out of bounds');
		assertTrue(to > from, 'Illegal argument: parameter \'to\' must be larger than parameter \'from\'');

		const length = to - from;
		const mask = (1 &lt;&lt; length) - 1;
		const bitField = new BitField(length);
		bitField.on((this.value >> from) &amp; mask);

		return bitField;
	}

	test(...masks) {
		const mask = BitField.combineMasks(...masks);

		return (this.value &amp; mask) === mask;
	}

	testAny(...masks) {
		const mask = BitField.combineMasks(...masks);

		return (this.value &amp; mask) !== 0;
	}

	testAt(value, index) {
		assertTrue(isInteger(index), 'Illegal argument: parameter \'index\' is not an integer');
		assertTrue(withinRange(index, 0, 31), 'Illegal argument: parameter \'index\' is out of bounds');

		return this.get(index) === Boolean(value);
	}

	testAll(value) {
		let mask = 0;

		if (value > 0) {
			mask = (value &lt;&lt; this.length) - 1;
		}

		return this.value === mask;
	}

	on(...masks) {
		return this.set(1, ...masks);
	}

	off(...masks) {
		return this.set(0, ...masks);
	}

	set(value, ...masks) {
		const mask = BitField.combineMasks(...masks);

		if (value > 0) {
			this.value |= mask;
		} else {
			this.value &amp;= ~mask;
		}

		return this;
	}

	setAll(value) {
		const mask = (1 &lt;&lt; this.length) - 1;

		return this.set(value, mask);
	}

	setAt(value, index) {
		assertTrue(isInteger(index), 'Illegal argument: parameter \'index\' is not an integer');
		assertTrue(withinRange(index, 0, 31), 'Illegal argument: parameter \'index\' is out of bounds');

		const mask = 1 &lt;&lt; index;

		return this.set(value, mask);
	}

	setRange(value, from, to) {
		assertTrue(isInteger(from), 'Illegal argument: parameter \'from\' is not an integer');
		assertTrue(isInteger(to), 'Illegal argument: parameter \'to\' is not an integer');
		assertTrue(withinRange(from, 0, 31), 'Illegal argument: parameter \'from\' is out of bounds');
		assertTrue(withinRange(to, 0, 31), 'Illegal argument: parameter \'to\' is out of bounds');
		assertTrue(to > from, 'Illegal argument: parameter \'to\' must be larger than parameter \'from\'');

		let mask = (1 &lt;&lt; (to - from)) - 1;

		if (from > 0) {
			mask *= 2 * from;
		}

		return this.set(value, mask);
	}

	flip(...masks) {
		this.value ^= BitField.combineMasks(...masks);

		return this;
	}

	flipAll() {
		const mask = (1 &lt;&lt; this.length) - 1;

		return this.flip(mask);
	}

	flipAt(index) {
		assertTrue(isInteger(index), 'Illegal argument: parameter \'index\' is not an integer');
		assertTrue(withinRange(index, 0, 31), 'Illegal argument: parameter \'index\' is out of bounds');

		const mask = 1 &lt;&lt; index;

		return this.flip(mask);
	}

	flipRange(from, to) {
		assertTrue(isInteger(from), 'Illegal argument: parameter \'from\' is not an integer');
		assertTrue(isInteger(to), 'Illegal argument: parameter \'to\' is not an integer');
		assertTrue(withinRange(from, 0, 31), 'Illegal argument: parameter \'from\' is out of bounds');
		assertTrue(withinRange(to, 0, 31), 'Illegal argument: parameter \'to\' is out of bounds');
		assertTrue(to > from, 'Illegal argument: parameter \'to\' must be larger than parameter \'from\'');

		let mask = (1 &lt;&lt; (to - from)) - 1;

		if (from > 0) {
			mask *= 2 * from;
		}

		return this.flip(mask);
	}

	copy(bitset) {
		this.value = BitField.valueOf(bitset);

		return this;
	}

	valueOf() {
		return this.value;
	}

	serialize() {
		let output = this.value.toString(2);

		if (this.minLength > output.length) {
			output = '0'.repeat(this.minLength - output.length) + output;
		}

		return output;
	}

	/**
	 * Deserializes a string and returns a new instance.
	 *
	 * @public
	 * @static
	 * @param {String} input
	 * @throws {Error} In case input could not be parsed.
	 * @returns {BitField} A new instance.
	 */
	static deserialize(input) {
		if (isNaN(Number(input))) {
			throw new Error('Failed to deserialize input');
		}

		const array = input.split('');

		return BitField.fromArray(array.map(Number));
	}

	/**
	 * Produces a new BitField instance equal to this.
	 *
	 * @public
	 * @returns {BitField} A new BitField instance.
	 */
	clone() {
		return new BitField().copy(this);
	}

	equals(other) {
		return this.value === BitField.valueOf(other);
	}

	toArray() {
		const array = [];
		let { value } = this;
		let length = 0;

		while (value > 0) {
			length++;
			array.push(Boolean(value &amp; 1));
			value >>= 1;
		}

		if (this.minLength > length) {
			const filler = new Array(this.minLength - length).fill(false);

			array.push(...filler);
		}

		return array.reverse();
	}

	toString() {
		return `BitField(${this.serialize()})`;
	}
}

export default BitField;
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a> on Sat Mar 06 2021 19:45:42 GMT+0100 (Central European Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
